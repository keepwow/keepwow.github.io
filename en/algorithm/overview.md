# Master Algorithm in 7 Days

>Thanks to [Labuladong](https://github.com/labuladong)！

**HERE ARE A FEW MUST-KNOW CODE IMPLEMENTSTIONS**

**Day 1**

## Array and Linked-List

### Array

- 实现一个支持动态扩容的数组
- 实现一个大小固定的有序数组，支持动态增删改操作
- 实现两个有序数组合并为一个有序数组

### Linked-List

- 实现单链表、循环链表、双向链表，支持增删操作
- 实现单链表反转
- 实现两个有序的链表合并为一个有序链表
- 实现求链表的中间结点

**LeetCode exercises**

### Array

- [Three Sum](https://leetcode.com/problems/3sum/)   ||   [求三数之和](https://leetcode-cn.com/problems/3sum/)

- [Majority Element](https://leetcode.com/problems/majority-element/)   ||   [求众数](https://leetcode-cn.com/problems/majority-element/)

- [Missing Positive](https://leetcode.com/problems/first-missing-positive/)   ||   [求缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)

### Linked List

- [Linked List Cycle I](https://leetcode.com/problems/linked-list-cycle/)   ||   [环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

- [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)   ||   [合并 k 个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

---

**Day 2**

## Stack, Queue & Recursion

### Stack

- 用数组实现一个顺序栈
- 用链表实现一个链式栈
- 编程模拟实现一个浏览器的前进、后退功能

### Queue

- 用数组实现一个顺序队列
- 用链表实现一个链式队列
- 实现一个循环队列

### Recursion

- 编程实现斐波那契数列求值 $f(n) = f(n-1) + f(n-2)$
- 编程实现求阶乘 $n!$
- 编程实现一组数据集合的全排列

**LeetCode exercises**

### Stack

- [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)   ||   [有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

- [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)   ||   [最长有效的括号](https://leetcode-cn.com/problems/longest-valid-parentheses/Evaluate)

- [Reverse Polish Notatio](https://leetcode.com/problems/evaluate-reverse-polish-notation/)   ||   [逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

### Queue
- [Design Circular Deque](https://leetcode.com/problems/design-circular-deque/)   ||   [设计一个双端队列](https://leetcode-cn.com/problems/design-circular-deque/)

- [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)   ||   [滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

### Recursion

[Climbing Stairs](https://leetcode.com/problems/climbing-stairs)   ||   [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

---

**Day 3**

## Sorting & Binary Search

### Sorting

- 实现归并排序、快速排序、插入排序、冒泡排序、选择排序
- 编程实现 O(n) 时间复杂度内找到一组数据的第 K 大元素

### Binary Search

- 实现一个有序数组的二分查找算法
- 实现模糊二分查找算法（比如大于等于给定值的第一个元素）

**LeetCode exercises**

[Sqrt(x)](https://leetcode.com/problems/sqrtx/)   ||   [x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

---

**Day 4**

## Hash Tables & String

### Hash Tables

- 实现一个基于链表法解决冲突问题的散列表
- 实现一个 LRU 缓存淘汰算法

### String

- 实现一个字符集，只包含 a～z 这 26 个英文字母的 Trie 树
- 实现朴素的字符串匹配算法

**LeetCode exercises**

### String

- [Reverse String](https://leetcode.com/problems/reverse-string/)   ||   [反转字符串](https://leetcode-cn.com/problems/reverse-string/)

- [Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/)   ||   [翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

- [String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/)   ||   [字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

---

**Day 5**

## Binary Tree & Heap

### Binary Tree

- 实现一个二叉查找树，并且支持插入、删除、查找操作
- 实现查找二叉查找树中某个节点的后继、前驱节点
- 实现二叉树前、中、后序以及按层遍历堆
- 实现一个小顶堆、大顶堆、优先级队列
- 实现堆排序利用优先级队列合并 K 个有序数组
- 求一组动态数据集合的最大 Top K

**LeetCode exercises**

- [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)   ||   [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

- [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)   ||   [二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

- [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)   ||   [验证二叉查找树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

- [Path Sum](https://leetcode.com/problems/path-sum/)   ||   [路径总和](https://leetcode-cn.com/problems/path-sum/)

---

**Day 6**

## Graph

### Graph

- 实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法
- 实现图的深度优先搜索、广度优先搜索
- 实现 Dijkstra 算法、A* 算法
- 实现拓扑排序的 Kahn 算法、DFS 算法

**LeetCode exercises**

- [Number of Islands](https://leetcode.com/problems/number-of-islands/description/)   ||   [岛屿的个数](https://leetcode-cn.com/problems/number-of-islands/description/)

- [Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)   ||   [有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

---

**Day 7**

## Algorithmic Thinking

### BackTracking

- 利用回溯算法求解八皇后问题
- 利用回溯算法求解 0-1 背包问题

### Divide & Conquer

- 利用分治算法求一组数据的逆序对个数

### Dynamic Programming

- 0-1 背包问题
- 最小路径和（[Minimum Path Sum]()）
- 编程实现莱文斯坦最短编辑距离
- 编程实现查找两个字符串的最长公共子序列
- 编程实现一个数据序列的最长递增子序列

**LeetCode exercises**

- [Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)   ||   [正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

- [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)   ||   [最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

- [Coin Change](https://leetcode.com/problems/coin-change/)   ||   [零钱兑换](https://leetcode-cn.com/problems/coin-change/)

- [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)   ||   [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

- [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)   ||   [乘积最大子序列](https://leetcode-cn.com/problems/maximum-product-subarray/)

- [Triangle](https://leetcode.com/problems/triangle/)   ||   [三角形最小路径和](https://leetcode-cn.com/problems/triangle/)
